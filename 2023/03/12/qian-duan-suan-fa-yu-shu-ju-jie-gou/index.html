<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="前端算法与数据结构, Ramona">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>前端算法与数据结构 | Ramona</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpeg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/love flowers.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Ramona</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/love flowers.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Ramona</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">前端算法与数据结构</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                <span class="chip bg-color">前端算法与数据结构</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-category">
                                数据结构与算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-12
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    48 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800346304526" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<p>评价算法的两个重要依据——时间复杂度和空间复杂度。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>示例如下规模为 <code>n*n</code> 的二维数组的遍历：A</p>
<p><img src="https://secure2.wostatic.cn/static/dNqmQpjSezcVky3KvaAfPk/image.png?auth_key=1678592198-9oxUCL3rJTBeJbYf2RmcJo-0-1dc5c364a2c4e9c33d67f8902fdef74a" alt="img"></p>
<p>上述代码的总执行次数：</p>
<pre class=" language-JavaScript"><code class="language-JavaScript">T(n) = 1 + 1 + (n+1) + n + n + n + n*(n+1) + n*n + n*n = 3n^2 + 5n + 3</code></pre>
<p>代码的执行次数，可以反映出代码的执行时间。算法的时间复杂度，它反映的不是算法的逻辑代码到底被执行了多少次，而是随着输入规模的增大，算法对应的执行总次数的一个<strong>变化趋势</strong>。要想反映趋势，直接抓主要矛盾就行。我们可以尝试对 T(n) 做如下处理：</p>
<ul>
<li>若 T(n) 是常数，那么无脑简化为1</li>
<li>若 T(n) 是多项式，比如 3n^2 + 5n + 3，我们只保留次数最高那一项，并且将其常数系数无脑改为1。</li>
</ul>
<p>T(n) 就被简化为了 O(n)：</p>
<pre class=" language-JavaScript"><code class="language-JavaScript">T(n) = 3n^2 + 5n + 3
O(n) = n^2</code></pre>
<p>常见的时间复杂度按照从小到大的顺序排列，有以下几种：</p>
<p><img src="https://secure2.wostatic.cn/static/6QcgnB8ZSrePevVZHy7eFg/image.png?auth_key=1678592198-qnJySN1XEKo5em186wXJWt-0-55a775269e1397bfddf6a68a05104066" alt="img"></p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。和时间复杂度相似，它是内存增长的<strong>趋势</strong>。常见的空间复杂度有 <code>O(1)</code>、<code>O(n)</code> 和 <code>O(n^2)</code>。</p>
<p>示例：初始化一个规模为 n 的数组，并且要求这个数组的每个元素的值与其索引始终是相等关系</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr
<span class="token punctuation">}</span></code></pre>
<p>在这个 <code>init</code> 中，涉及到的占用内存的变量有以下几个：</p>
<pre class=" language-js"><code class="language-js">n 
arr
i</code></pre>
<p>这个 <code>arr</code>，它并不是一个一成不变的数组。<code>arr</code>最终的大小是由输入的 <code>n</code> 的大小决定的，它会随着 <code>n</code> 的增大而增大、呈一个线性关系。因此这个算法的空间复杂度就是 <code>O(n)</code>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800342093832" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="1、一维数组的创建"><a href="#1、一维数组的创建" class="headerlink" title="1、一维数组的创建"></a>1、一维数组的创建</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方式一</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 
<span class="token comment" spellcheck="true">// 方式二：常用于创造指定长度的空数组，如下传入一个参数，就表示能得到多大的数组</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>创建一个确定的数组</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建一个长度为7、同时每一个元素的值都为1的数组</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<h4 id="2、数组的访问"><a href="#2、数组的访问" class="headerlink" title="2、数组的访问"></a>2、数组的访问</h4><pre class=" language-js"><code class="language-js">arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 访问索引下标为0的元素</span></code></pre>
<h4 id="3、数组的遍历"><a href="#3、数组的遍历" class="headerlink" title="3、数组的遍历"></a>3、数组的遍历</h4><p>（1）<strong>for循环</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 获取数组的长度</span>
<span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 输出数组的元素值，输出当前索引</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>（2）<strong>forEach 方法</strong></p>
<pre class=" language-js"><code class="language-js">arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 输出数组的元素值，输出当前索引</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>（3）<strong>map 方法</strong></p>
<p>其主要相当于在遍历数组的基础上“再加工”。可以根据传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 输出数组的元素值，输出当前索引</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 在当前元素值的基础上加1</span>
    <span class="token keyword">return</span> item<span class="token operator">+</span><span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>建议：如果没有特殊需要，最好统一使用 for 循环来实现遍历。因为<strong>从性能上看，for 循环遍历起来是最快的</strong>。</p>
<h4 id="4、数组新增元素"><a href="#4、数组新增元素" class="headerlink" title="4、数组新增元素"></a>4、数组新增元素</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>

<span class="token comment" spellcheck="true">// 方式1：unshift 方法-添加元素到数组的头部</span>
arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [0,1,2]</span>

<span class="token comment" spellcheck="true">// 方式2：push 方法-添加元素到数组的尾部</span>
arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1,2,3]</span>

<span class="token comment" spellcheck="true">// 方式3：splice 方法-添加元素到数组的任何位置</span>
arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> 
consoloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// // [1,3,2]</span></code></pre>
<p>1、splice 语法，第一个入参是起始的<strong>索引值</strong>，第二个入参表示从起始索引开始<strong>需要删除的元素个数</strong>，第三个参数是用于在删除的同时<strong>新增数组元素</strong>，从第三个位置开始的入参，都代表着需要添加到数组里的元素的值。2、<strong>返回删除的元素数组，会改变原始数组</strong>。</p>
<h4 id="5、数组删除元素"><a href="#5、数组删除元素" class="headerlink" title="5、数组删除元素"></a>5、数组删除元素</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>

<span class="token comment" spellcheck="true">// 方式1：shift 方法-删除数组头部的元素</span>
arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [2,3]</span>

<span class="token comment" spellcheck="true">// 方式2：pop 方法-删除数组尾部的元素</span>
arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1,2]</span>

<span class="token comment" spellcheck="true">// 方式3：splice 方法-删除数组任意位置的元素</span>
app<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
consoloe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,3]</span></code></pre>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组其实就是数组套数组，也就是每个元素都是数组的数组。<strong>别名叫“矩阵”</strong>。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span></code></pre>
<h4 id="1、二维数组的创建及初始化"><a href="#1、二维数组的创建及初始化" class="headerlink" title="1、二维数组的创建及初始化"></a>1、二维数组的创建及初始化</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 将数组的每一个坑位初始化为数组</span>
    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<p>在初始化时，不要使用fill([]) 去填充二维数组元素，因为如果当想修改某一个二维数组中的值时，使用 arr[0][0] = 1 这种方式，会把一整列的元素都被设为了 1，这是由于当你给 fill 传递一个入参时，<strong>如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用</strong>。</p>
<h4 id="2、二维数组的访问"><a href="#2、二维数组的访问" class="headerlink" title="2、二维数组的访问"></a>2、二维数组的访问</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 缓存外部数组的长度</span>
<span class="token keyword">const</span> outerLen <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> outerLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 缓存内部数组的长度</span>
    <span class="token keyword">const</span> innerLen <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> innerLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 输出数组的值，输出数组的索引</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="数组专题应用"><a href="#数组专题应用" class="headerlink" title="数组专题应用"></a>数组专题应用</h3><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800350498824" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<p>总结归纳 1、几乎所有的求和问题，都可以转化为<strong>求差问题</strong>。 2、双指针法。【关键字：“有序”和“数组”】 （1）普通双指针法【两个指针在数组尾端或起端】。 （2）对撞双指针法【左右指针一起从两边往中间位置相互迫近】</p>
<p><strong>1、</strong><a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noopener"><strong>两数之和</strong></a></p>
<p>可以在遍历数组的过程中，增加一个 Map 来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到 Map 里去查询 targetNum 与该数的<strong>差值</strong>是否已经在前面的数字中出现过了。若出现过，则得到答案。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** map妙用
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> twoSum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/** 对象字面量定义，实现类似map的效果
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */</span>
<span class="token keyword">const</span> twoSum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 这里我用对象来模拟 map 的能力</span>
    <span class="token keyword">const</span> diffs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 缓存数组长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
    <span class="token comment" spellcheck="true">// 遍历数组</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 判断当前值对应的 target 差值是否存在（是否已遍历过）</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>diffs<span class="token punctuation">[</span>target<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!==</span>undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 若有对应差值，那么答案get！</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>diffs<span class="token punctuation">[</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 若没有对应差值，则记录当前值</span>
        diffs<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>i
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><strong>2、</strong><a href="https://leetcode.cn/problems/merge-sorted-array/" target="_blank" rel="noopener"><strong>合并两个有序数组</strong></a></p>
<p>给定两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<p>首先定义两个指针，各指向两个数组生效部分的尾部，每次只对指针所指的元素进行比较，取其中较大的元素，把它从 nums1 的末尾往前面填补。</p>
<p>为什么是从后往前填补？因为是要把所有的值合并到 nums1 里，所以说我们这里可以把 nums1 看做是一个“容器”。但是这个容器，它不是空的，而是前面几个坑有内容的。如果我们从前往后填补，就没法直接往对应的坑位赋值了（会产生值覆盖）。从后往前填补，我们填的都是没有内容的坑，这样会省掉很多麻烦。</p>
<p>由于 nums1 的有效部分和 nums2 并不一定是一样长的。我们还需要考虑其中一个数组提前到头的这种情况：</p>
<ol>
<li>如果提前遍历完的是 nums1 的有效部分，剩下的是 nums2。那么这时意味着 nums1 的头部空出来了，直接把 nums2 整个补到 nums1 前面去即可。</li>
<li>如果提前遍历完的是 nums2，剩下的是 nums1。由于容器本身就是 nums1，所以此时不必做任何额外的操作。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */</span>
<span class="token keyword">const</span> merge <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> m<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化两个指针的指向，初始化 nums1 尾部索引k</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token comment" spellcheck="true">// 当两个数组都没遍历完时，指针同步移动</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 取较大的值，从末尾往前填补</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> 
            i<span class="token operator">--</span> 
            k<span class="token operator">--</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> 
            j<span class="token operator">--</span> 
            k<span class="token operator">--</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// nums2 留下的情况，特殊处理一下 </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  
        k<span class="token operator">--</span> 
        j<span class="token operator">--</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><strong>3、</strong><a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener"><strong>三数求和</strong></a></p>
<p>我们可以<strong>把求和问题变成求差问题</strong>——固定其中一个数，在剩下的数中寻找是否有两个数和这个固定数相加是等于0的。</p>
<p>首先，对于无序数组，先将数组排序，然后，对数组进行遍历，每次遍历到哪个数字，就固定哪个数字。然后把左指针指向该数字后面一个坑里的数字，把右指针指向数组末尾，让左右指针从起点开始，向中间前进：</p>
<p><img src="https://secure2.wostatic.cn/static/qB56hBD42CRTZKZZdUNozG/image.png?auth_key=1678592212-jkSKPSLaaM8os8kRuBUUV8-0-f5a8316d2c6b20ad36c2d79628361dfe" alt="img"></p>
<p>每次指针移动一次位置，就计算一下两个指针指向数字之和加上固定的那个数之后，是否等于0。如果是，那么我们就得到了一个目标组合；否则，分两种情况来看：</p>
<ul>
<li>相加之和大于0，说明右侧的数偏大了，右指针左移</li>
<li>相加之和小于0，说明左侧的数偏小了，左指针右移</li>
</ul>
<p>此外，还要注意还需要做一个重复元素的跳过处理。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {number[]} nums
 * @return {number[][]}
 */</span>
<span class="token keyword">const</span> threeSum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 用于存放结果数组</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 
    <span class="token comment" spellcheck="true">// 给 nums 排序</span>
    nums <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token operator">-</span>b
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 缓存数组长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
    <span class="token comment" spellcheck="true">// 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token number">-2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 左指针 j</span>
        <span class="token keyword">let</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> 
        <span class="token comment" spellcheck="true">// 右指针k</span>
        <span class="token keyword">let</span> k<span class="token operator">=</span>len<span class="token number">-1</span>   
        <span class="token comment" spellcheck="true">// 如果遇到重复的数字，则跳过</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 三数之和小于0，左指针前进</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                j<span class="token operator">++</span>
               <span class="token comment" spellcheck="true">// 处理左指针元素重复的情况</span>
               <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    j<span class="token operator">++</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 三数之和大于0，右指针后退</span>
                k<span class="token operator">--</span>

               <span class="token comment" spellcheck="true">// 处理右指针元素重复的情况</span>
               <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    k<span class="token operator">--</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 得到目标数字组合，推入结果数组</span>
                res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

                <span class="token comment" spellcheck="true">// 左右指针一起前进</span>
                j<span class="token operator">++</span>  
                k<span class="token operator">--</span>

                <span class="token comment" spellcheck="true">// 若左指针元素重复，跳过</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    j<span class="token operator">++</span>
                <span class="token punctuation">}</span>  

               <span class="token comment" spellcheck="true">// 若右指针元素重复，跳过</span>
               <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    k<span class="token operator">--</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 返回结果数组</span>
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800342093837" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>栈是一种后进先出(LIFO，Last In First Out)的数据结构，它有两个特征：</p>
<ul>
<li>只允许从尾部添加元素</li>
<li>只允许从尾部取出元素</li>
</ul>
<p>对应到数组的方法，刚好就是 push 和 pop。因此，我们可以认为在 JavaScript 中，栈就是限制只能用 push 来添加元素，同时只能用 pop 来移除元素的一种特殊的数组。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 初始状态，栈空</span>
<span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
<span class="token comment" spellcheck="true">// 入栈过程</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'东北大板'</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'可爱多'</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'巧乐兹'</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'冰工厂'</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'光明奶砖'</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 出栈过程，栈不为空时才执行</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 单纯访问栈顶元素（不出栈）</span>
    <span class="token keyword">const</span> top <span class="token operator">=</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'现在取出的冰淇淋是'</span><span class="token punctuation">,</span> top<span class="token punctuation">)</span>  
    <span class="token comment" spellcheck="true">// 将栈顶元素出栈</span>
    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 栈空</span>
stack <span class="token comment" spellcheck="true">// []</span></code></pre>
<h3 id="栈专题应用"><a href="#栈专题应用" class="headerlink" title="栈专题应用"></a>栈专题应用</h3><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800354709511" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<p>总结归纳 1、题目中若涉及括号问题，则很有可能和栈相关。 2、考虑维护一个辅助栈、递减栈，利用空间换时间。</p>
<p><a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noopener"><strong>1、有效的括号</strong></a></p>
<p>使用栈实现，思路就是在遍历字符串的过程中，往栈里 push 括号对应的配对字符。比如如果遍历到了 <code>(</code>，就往栈里 push <code>)</code>。当字符串遍历得到的是右括号时，看栈顶出栈得到的数据和遍历的数据是否一致，如果一直则继续遍历对比，直到全部对比完成。不一致则说明配对失败，返回false。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 用一个 map 来维护左括号和右括号的对应关系</span>
<span class="token keyword">const</span> leftToRight <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string">"("</span><span class="token punctuation">:</span> <span class="token string">")"</span><span class="token punctuation">,</span>
  <span class="token string">"["</span><span class="token punctuation">:</span> <span class="token string">"]"</span><span class="token punctuation">,</span>
  <span class="token string">"{"</span><span class="token punctuation">:</span> <span class="token string">"}"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @param {string} s
 * @return {boolean}
 */</span>
<span class="token keyword">const</span> isValid <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 结合题意，空字符串无条件判断为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 初始化 stack 数组</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 缓存字符串长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 遍历字符串</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 缓存单个字符</span>
    <span class="token keyword">const</span> ch <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 判断是否是左括号，这里我为了实现加速，没有用数组的 includes 方法，直接手写判断逻辑</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">===</span> <span class="token string">"("</span> <span class="token operator">||</span> ch <span class="token operator">===</span> <span class="token string">"{"</span> <span class="token operator">||</span> ch <span class="token operator">===</span> <span class="token string">"["</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftToRight<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 若不是左括号，则必须是和栈顶的左括号相配对的右括号</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 若栈不为空，且栈顶的左括号没有和当前字符匹配上，那么判为无效</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span>length <span class="token operator">||</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 若所有的括号都能配对成功，那么最后栈应该是空的</span>
  <span class="token keyword">return</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noopener"><strong>2、每日温度</strong></a></p>
<p>暴力遍历法：直接两层遍历，第一层定位一个温度，第二层定位离这个温度最近的一次升温是哪天，然后求出两个温度对应索引的差值即可。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {number[]} temperatures
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> dailyTemperatures <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>temperatures<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> temperatures<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>temperatures<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>使用栈实现。<strong>尝试去维持一个递减栈</strong>。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {number[]} T
 * @return {number[]}
 */</span>
<span class="token comment" spellcheck="true">// 入参是温度数组</span>
<span class="token keyword">const</span> dailyTemperatures <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> T<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">// 缓存数组的长度 </span>
    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 初始化一个栈   </span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//  初始化结果数组，注意数组定长，占位为0</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 若栈不为0，且存在打破递减趋势的温度值</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> T<span class="token punctuation">[</span>stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将栈顶温度值对应的索引出栈</span>
        <span class="token keyword">const</span> top <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
        <span class="token comment" spellcheck="true">// 计算 当前栈顶温度值与第一个高于它的温度值 的索引差值</span>
        res<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> top 
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">// 注意栈里存的不是温度值，而是索引值，这是为了后面方便计算</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回结果数组</span>
    <span class="token keyword">return</span> res 
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/min-stack/" target="_blank" rel="noopener"><strong>3、最小栈</strong></a></p>
<p>暴力解法</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * 初始化你的栈结构
 */</span>
<span class="token keyword">const</span> MinStack <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/** 
 * @param {number} x
 * @return {void}
 */</span>
<span class="token comment" spellcheck="true">// 栈的入栈操作，其实就是数组的 push 方法</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @return {void}
 */</span>
<span class="token comment" spellcheck="true">// 栈的入栈操作，其实就是数组的 pop 方法</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>pop <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @return {number}
 */</span>
<span class="token comment" spellcheck="true">// 取栈顶元素，咱们教过的哈，这里我本能地给它一个边界条件判断（其实不给也能通过，但是多做不错哈）</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> 
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @return {number}
 */</span>
<span class="token comment" spellcheck="true">// 按照一次遍历的思路取最小值</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getMin <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> minValue <span class="token operator">=</span> <span class="token number">Infinity</span>  
    <span class="token keyword">const</span>  <span class="token punctuation">{</span> stack <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            minValue <span class="token operator">=</span> stack<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> minValue
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>使用辅助栈 stack2。实现的是一个从<code>栈底到栈顶呈递减趋势的栈</code>。</p>
<ul>
<li>取最小值：由于整个栈从栈底到栈顶递减，因此栈顶元素就是最小元素。</li>
<li>若有新元素入栈：判断是不是比栈顶元素还要小，否则不准进入 <code>stack2</code>。</li>
<li>若有元素出栈：判断是不是和栈顶元素相等，如果是的话，<code>stack2</code> 也要出栈。</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> MinStack <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 定义辅助栈</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/** 
 * @param {number} x
 * @return {void}
 */</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 若入栈的值小于当前最小值，则推入辅助栈栈顶</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @return {void}
 */</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>pop <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 若出栈的值和当前最小值相等，那么辅助栈也要对栈顶元素进行出栈，确保最小值的有效性</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @return {number}
 */</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @return {number}
 */</span>
MinStack<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getMin <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 辅助栈的栈顶，存的就是目标中的最小值</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800342093837" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><p>队列是一种先进先出（FIFO，First In First Out）的数据结构。它也有两个特征：</p>
<ul>
<li>只允许从尾部添加元素</li>
<li>只允许从头部移除元素</li>
</ul>
<p>对应到数组方法，就是数组的 push 和 shift 方法。因此，我们可以认为在 JavaScript 中，栈就是限制只能用 push 来添加元素，同时只能用shift来移除元素的一种特殊的数组。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'小册一姐'</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'小册二姐'</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'小册三姐'</span><span class="token punctuation">)</span>  

<span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 单纯访问队头元素（不出队）</span>
    <span class="token keyword">const</span> top <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span><span class="token string">'取餐'</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 将队头元素出队</span>
    queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 队空</span>
queue <span class="token comment" spellcheck="true">// []</span></code></pre>
<h3 id="队列专题应用"><a href="#队列专题应用" class="headerlink" title="队列专题应用"></a>队列专题应用</h3><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800358871054" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<p>总结归纳 1、题目中若涉及括号问题，则很有可能和栈相关。 2、</p>
<p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/" target="_blank" rel="noopener"><strong>1、用栈实现队列</strong></a></p>
<p>用栈实现队列，说白了就是用栈实现先进先出的效果，再说直接点，就是想办法<strong>让栈底的元素首先被取出</strong>，也就是让出栈序列被<strong>逆序</strong>。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * 初始化构造函数
 */</span>
<span class="token keyword">const</span> MyQueue <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 初始化两个栈</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
* Push element x to the back of queue.
* @param {number} x
* @return {void}
*/</span>
MyQueue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 直接调度数组的 push 方法</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
* Removes the element from in front of queue and returns that element.
* @return {number}
*/</span>
MyQueue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>pop <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 假如 stack2 为空，需要将 stack1 的元素转移进来</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 当 stack1 不为空时，出栈</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 将 stack1 出栈的元素推入 stack2</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 为了达到逆序的目的，我们只从 stack2 里出栈元素</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
* Get the front element.
* @return {number}
* 这个方法和 pop 唯一的区别就是没有将定位到的值出栈
*/</span>
MyQueue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>peek <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 当 stack1 不为空时，出栈</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 将 stack1 出栈的元素推入 stack2</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 缓存 stack2 的长度</span>
  <span class="token keyword">const</span> stack2Len <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">return</span> stack2Len <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">[</span>stack2Len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
* Returns whether the queue is empty.
* @return {boolean}
*/</span>
MyQueue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>empty <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 若 stack1 和 stack2 均为空，那么队列空</span>
  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener"><strong>2、滑动窗口的最大值</strong></a></p>
<p>双指针 + 遍历实现。定义一个 <code>left</code> 左指针、定义一个 <code>right</code> 右指针，分别指向窗口的两端，接下来我们可以把这个窗口里的数字取出来，直接遍历一遍、求出最大值，然后把最大值存进结果数组。这样第一个窗口的最大值就有了。然后左右指针再前进一步，重复上述过程。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */</span>
<span class="token keyword">const</span> maxSlidingWindow <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 缓存数组的长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 定义结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 初始化左指针</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 初始化右指针</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 当数组没有被遍历完时，执行循环体内的逻辑</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 计算当前窗口内的最大值</span>
    <span class="token keyword">const</span> max <span class="token operator">=</span> <span class="token function">calMax</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将最大值推入结果数组</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 左指针前进一步</span>
    left<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 右指针前进一步</span>
    right<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 返回结果数组</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 这个函数用来计算最大值</span>
<span class="token keyword">function</span> <span class="token function">calMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 处理数组为空的边界情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> <span class="token operator">!</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 初始化 maxNum 的值为窗口内第一个元素</span>
  <span class="token keyword">let</span> maxNum <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 遍历窗口内所有元素，更新 maxNum 的值</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> maxNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      maxNum <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 返回最大值</span>
  <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>双端队列实现。<strong>双端队列就是允许在队列的两端进行插入和删除的队列</strong>。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800350482445" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>总结归纳 1、回文字符串对称性。 2、双指针法。 3、正则表达式。</p>
<p><a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener"><strong>1、反转字符串</strong></a></p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {character[]} s 输入字符数组 s
 * @return {void} Do not return anything, modify s in-place instead.
 */</span>
<span class="token keyword">var</span> reverseString <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 输入字符串 str: abcde</span>
<span class="token keyword">var</span> reverseString <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/valid-palindrome/" target="_blank" rel="noopener"><strong>2、验证回文串</strong></a></p>
<p>回文字符串，就是正着读和倒着读都一样的字符串。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方式1 反转字符串和原字符串对比</span>
<span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//先替换掉所有非字母和数字,再替换掉所有的空格</span>
    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/[^a-zA-Z0-9]/g</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\s/g</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 先反转字符串</span>
    <span class="token keyword">const</span> reversedStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 判断反转前后是否相等</span>
    <span class="token keyword">return</span> reversedStr <span class="token operator">===</span> str
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式2 对称性</span>
<span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//先替换掉所有非字母和数字,再替换掉所有的空格</span>
    s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/[^a-zA-Z0-9]/g</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\s/g</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 缓存字符串的长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span>length
    <span class="token comment" spellcheck="true">// 遍历前半部分，判断和后半部分是否对称</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!==</span>str<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span></code></pre>
<p><a href="https://leetcode.cn/problems/valid-palindrome-ii/" target="_blank" rel="noopener"><strong>3、验证回文串 II</strong></a></p>
<p>使用对称性和双指针方法实现。首先是初始化两个指针，一个指向字符串头部，另一个指向尾部：</p>
<p><img src="https://secure2.wostatic.cn/static/ucB6HitrMFf3x2MwP8Did7/image.png?auth_key=1678593130-qvSPG5UWSTdNEBG52EdMxG-0-0166b586222778da6c7d3a4c01786533" alt="img"></p>
<p>如果两个指针所指的字符恰好相等，那么这两个字符就符合了回文字符串对对称性的要求，跳过它们往下走即可。如果两个指针所指的字符串不等，那么就意味着不对称发生了，意味着这是一个可以“删掉试试看”的操作点。我们可以分别对左指针字符和右指针字符尝试进行“跳过”，看看区间在 <code>[left+1, right]</code> 或 <code>[left, right-1]</code> 的字符串是否回文。如果是的话，那么就意味着如果删掉被“跳过”那个字符，整个字符串都将回文。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> validPalindrome <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 缓存字符串的长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length

    <span class="token comment" spellcheck="true">// i、j分别为左右指针</span>
    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token operator">=</span>len<span class="token number">-1</span>

    <span class="token comment" spellcheck="true">// 当左右指针均满足对称时，一起向中间前进</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">===</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">++</span> 
        j<span class="token operator">--</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 尝试判断跳过左指针元素后字符串是否回文</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 尝试判断跳过右指针元素后字符串是否回文</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 工具方法，用于判断字符串是否回文</span>
    <span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> ed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token operator">&lt;</span>ed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>st<span class="token punctuation">]</span> <span class="token operator">!==</span> s<span class="token punctuation">[</span>ed<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span>
            <span class="token punctuation">}</span>
            st<span class="token operator">++</span>
            ed<span class="token operator">--</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 默认返回 false</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener"><strong>4、把字符串转换成整数</strong></a></p>
<p>Step1：计算最大值和最小值</p>
<p>Step2：解析字符串：可能存在的空格+正负号+数字字符串+其它字符内容</p>
<blockquote>
<p><code>\s</code> 这个符号，意味着空字符，它可以用来匹配回车、空格、换行等空白区域，这里，它用来被匹配空格。<code>*</code>这个符号，跟在其它符号后面，意味着“前面这个符号可以出现0次或多次。 <code>[]</code>中的匹配符之间是“或”的关系，<code>[-\+]</code> 表示允许字符串的第一个有效字符为“+”或者“—”。 <code>[0-9]*</code> 是0-9之间的整数，能匹配到0个或多个就算匹配成功。 <code>.</code>是任意字符的意思，<code>.*</code>用于字符串尾部匹配非数字的任意字符。我们看到<code>.*</code>是被排除捕获组之外的，所以说这个东西其实也不会被额外存储，它被“摘除”了。</p>
</blockquote>
<p>Step3：获取捕获结果</p>
<p>JS 的正则相关方法中， <code>test()</code>方法返回的是一个布尔值，单纯判断“是否匹配”。</p>
<p>要想获取匹配的结果，我们需要调度<code>match()</code>方法，<code>match()</code> 方法是一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</p>
<p>如果我们的正则表达式尾部有 g 标志，<code>match()</code>会返回与完整正则表达式匹配的所有结果，但不会返回捕获组。</p>
<p>这里我们没有使用g标志，<code>match()</code>就会返回第一个完整匹配（作为数组的第0项）及其相关的捕获组（作为数组的第1及第1+项）。这里我们只定义了一个捕获组，因此可以从 <code>groups[1]</code> 里拿到我们捕获的结果。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {string} str
 * @return {number}
 */</span>
<span class="token keyword">const</span> strToInt <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 编写正则表达式</span>
    <span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex">/\s*([-\+]?[0-9]*).*/</span>
    <span class="token comment" spellcheck="true">// 得到捕获组</span>
    <span class="token keyword">const</span> groups <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 计算最大值</span>
    <span class="token keyword">const</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token comment" spellcheck="true">// 计算最小值</span>
    <span class="token keyword">const</span> min <span class="token operator">=</span> <span class="token operator">-</span>max <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token comment" spellcheck="true">// targetNum 用于存储转化出来的数字</span>
    <span class="token keyword">let</span> targetNum <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment" spellcheck="true">// 如果匹配成功</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>groups<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 尝试转化捕获到的结构</span>
        targetNum <span class="token operator">=</span> <span class="token operator">+</span>groups<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token comment" spellcheck="true">// 注意，即便成功，也可能出现非数字的情况，比如单一个'+'</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>targetNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 不能进行有效的转换时，请返回 0</span>
            targetNum <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 卡口判断</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>targetNum <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> max
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> targetNum <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> min
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回转换结果</span>
    <span class="token keyword">return</span> targetNum
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800342093837" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<p>在链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是<strong>离散</strong>的，链表同数组类似，都是线性结构（有且仅有一个前驱、有且仅有一个后继）。</p>
<h3 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="1、链表和数组的区别"><a href="#1、链表和数组的区别" class="headerlink" title="1、链表和数组的区别"></a>1、链表和数组的区别</h4><p>数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段<strong>连续</strong>的内存空间。由于数组中的元素是连续的，每个元素的内存地址可以根据其索引距离数组头部的距离来计算出来。因此对数组来说，每一个元素都可以通过数组的索引下标直接定位。</p>
<p><strong>数组的访问效率较高，而插入效率较低</strong>。</p>
<p>而链表中的结点，则允许<strong>散落</strong>在内存空间的各个角落里。元素和元素之间似乎毫无内存上的瓜葛可言，没有关联，因此需要创建关联。在链表中，每一个结点的结构都包括了两部分的内容：<strong>数据域和指针域</strong>。</p>
<p><strong>链表的插入/删除效率较高，而访问效率较低。</strong></p>
<h4 id="2、JS链表实现"><a href="#2、JS链表实现" class="headerlink" title="2、JS链表实现"></a>2、JS链表实现</h4><p>以嵌套的对象形式来实现，如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 数据域</span>
    val<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 指针域，指向下一个结点</span>
    next<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        val<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span>
        next<span class="token punctuation">:</span> <span class="token operator">...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>   </code></pre>
<p>数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。</p>
<h4 id="3、链表结点的创建"><a href="#3、链表结点的创建" class="headerlink" title="3、链表结点的创建"></a>3、链表结点的创建</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span></code></pre>
<h4 id="4、链表元素的添加"><a href="#4、链表元素的添加" class="headerlink" title="4、链表元素的添加"></a>4、链表元素的添加</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方式一：链表尾部添加结点，直接改变尾部的一个next 指针就行</span>
<span class="token keyword">const</span> node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
node2<span class="token punctuation">.</span>next <span class="token operator">=</span> node3<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 方式二：任意两结点间插入一个新结点(包括头结点)</span>
<span class="token comment" spellcheck="true">// 如果目标结点本来不存在，那么记得手动创建</span>
<span class="token keyword">const</span> node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 把node3的 next 指针指向 node2（即 node1.next）</span>
node3<span class="token punctuation">.</span>next <span class="token operator">=</span> node1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 把node1的 next 指针指向 node3</span>
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node3<span class="token punctuation">;</span></code></pre>
<h4 id="5、链表元素的删除"><a href="#5、链表元素的删除" class="headerlink" title="5、链表元素的删除"></a>5、链表元素的删除</h4><p>把上边添加进来的 node3 从现在的链表里删掉</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方式一：链表尾部删除结点，直接改变尾部的一个next 指针就行</span>
node2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 方式二：任意两结点间插入一个新结点(包括头结点)</span>
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node3<span class="token punctuation">.</span>next</code></pre>
<p>注意点：在涉及链表删除操作的题目中，重点不是定位目标结点，而是<strong>定位目标结点的前驱结点</strong>。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 利用 node1 可以定位到 node3</span>
<span class="token keyword">const</span> target <span class="token operator">=</span> node1<span class="token punctuation">.</span>next  
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> target<span class="token punctuation">.</span>next</code></pre>
<h4 id="6、链表和数组的辨析"><a href="#6、链表和数组的辨析" class="headerlink" title="6、链表和数组的辨析"></a>6、链表和数组的辨析</h4><p>在大多数的计算机语言中，<strong>我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)</strong>。</p>
<p>但 JS 中不一定是。  如果我们在一个数组中只定义了一种类型的元素，如纯数字数组 arr = [1,2,3]，那么对应的确实是连续内存。</p>
<p>但如果我们定义了不同类型的元素，如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'haha'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre>
<p>它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。</p>
<p>所以，<strong>“JS 数组未必是真正的数组”</strong>。</p>
<h3 id="链表专题应用"><a href="#链表专题应用" class="headerlink" title="链表专题应用"></a>链表专题应用</h3><p>总结归纳 1、链表循环，大部分都用 while 循环。 2、处理链表的本质，是处理链表结点之间的指针关系。 3、惯用  <code>dummy</code> 结点【人为制造出来的链表第一个结点的前驱结点】，解决链表头结点不存在前驱结点问题，尤其是涉及结点删除的题目。 4、涉及反复遍历的题目常用快慢指针或者多指针法解决。 5、环形链表可通过立flag的方式进行判断。</p>
<h3 id="链表基本处理"><a href="#链表基本处理" class="headerlink" title="链表基本处理"></a>链表基本处理</h3><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800350498823" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/" target="_blank" rel="noopener"><strong>1、合并两个有序链表</strong></a></p>
<p>处理链表的本质，是处理链表结点之间的指针关系。两个链表如果想要合并为一个链表，我们恰当地补齐双方之间结点 next 指针的指向关系，然后通过比较链表值进行穿针。</p>
<p>同时我们还要考虑 l1 和 l2 两个链表长度不等的情况：若其中一个链表已经完全被串进新链表里了，而另一个链表还有剩余结点，考虑到该链表本身就是有序的，我们可以直接把它整个拼到目标链表的尾部。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> mergeTwoLists <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 定义头结点，确保链表可以被访问到</span>
  <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// cur 这里就是咱们那根“针”</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head
  <span class="token comment" spellcheck="true">// “针”开始在 l1 和 l2 间穿梭了</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 如果 l1 的结点值较小</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token operator">&lt;=</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 先串起 l1 的结点</span>
          cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1
          <span class="token comment" spellcheck="true">// l1 指针向前一步</span>
          l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// l2 较小时，串起 l2 结点</span>
          cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2
          <span class="token comment" spellcheck="true">// l2 向前一步</span>
          l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next
      <span class="token punctuation">}</span>

      <span class="token comment" spellcheck="true">// “针”在串起一个结点后，也会往前一步</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next 

  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 处理链表不等长的情况</span>
  cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token operator">!==</span><span class="token keyword">null</span><span class="token operator">?</span>l1<span class="token punctuation">:</span>l2
  <span class="token comment" spellcheck="true">// 返回起始结点</span>
  <span class="token keyword">return</span> head<span class="token punctuation">.</span>next
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener"><strong>2、删除排序链表中的重复元素</strong></a></p>
<p>删除链表元素，将需要删除的目标结点的前驱结点 next 指针往后指一格。判断两个元素是否重复，由于此处是已排序的链表，我们直接判断前后两个元素值是否相等即可。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> deleteDuplicates <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 设定 cur 指针，初始位置为链表第一个结点</span>
    <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 遍历链表</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 若当前结点和它后面一个结点值相等（重复）</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">===</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 删除靠后的那个结点（去重）</span>
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 若不重复，继续遍历</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener"><strong>3、删除排序链表中的重复元素 II</strong></a></p>
<p>我们要删除某一个目标结点时，必须知道它的<strong>前驱结点</strong>。如果是链表的第一个结点，因为没有前驱结点，这时我们就可以用一个 <code>dummy</code> 结点来解决这个问题。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> deleteDuplicates <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 极端情况：0个或1个结点，则不会重复，直接返回</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> head
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// dummy 登场</span>
    <span class="token keyword">let</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token comment" spellcheck="true">// dummy 永远指向头结点</span>
    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head   
    <span class="token comment" spellcheck="true">// cur 从 dummy 开始遍历</span>
    <span class="token keyword">let</span> cur <span class="token operator">=</span> dummy 
    <span class="token comment" spellcheck="true">// 当 cur 的后面有至少两个结点时</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 对 cur 后面的两个结点进行比较</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">===</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 若值重复，则记下这个值</span>
            <span class="token keyword">let</span> val <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val
            <span class="token comment" spellcheck="true">// 反复地排查后面的元素是否存在多次重复该值的情况</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token operator">===</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 若有，则删除</span>
                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next 
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 若不重复，则正常遍历</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回链表的起始结点</span>
    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="链表的反转及其衍生题目"><a href="#链表的反转及其衍生题目" class="headerlink" title="链表的反转及其衍生题目"></a>链表的反转及其衍生题目</h3><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800354676743" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<p><a href="https://leetcode.cn/problems/SLwz0R/" target="_blank" rel="noopener"><strong>1、删除链表的倒数第 n 个结点</strong></a></p>
<p>考虑到咱们的遍历不可能从后往前走，因此这个“倒数第 N 个” 咱们完全可以转换为“正数第 <code>len - n + 1</code>“个。</p>
<p>首先设定两个指针 <code>slow</code> 和 <code>fast</code>，全部指向链表的起始位——<code>dummy</code> 结点。然后快指针先出发，闷头走上 <code>n</code> 步，在第 <code>n</code> 个结点处打住。然后，快慢指针一起前进，当快指针前进到最后一个结点处时，两个指针再一起停下来。此时，慢指针所指的位置，就是倒数第 <code>n</code> 个结点的前一个结点，此时执行删除操作即可。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> removeNthFromEnd <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化 dummy 结点</span>
    <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// dummy指向头结点</span>
    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head
    <span class="token comment" spellcheck="true">// 初始化快慢指针，均指向dummy</span>
    <span class="token keyword">let</span> fast <span class="token operator">=</span> dummy
    <span class="token keyword">let</span> slow <span class="token operator">=</span> dummy

    <span class="token comment" spellcheck="true">// 快指针闷头走 n 步</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">!==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next
        n<span class="token operator">--</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 快慢指针一起走</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 慢指针删除自己的后继结点</span>
    slow<span class="token punctuation">.</span>next <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
    <span class="token comment" spellcheck="true">// 返回头结点</span>
    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener"><strong>2、反转链表</strong></a></p>
<p>使用多指针法。我们需要用到三个指针，它们分别指向目标结点（cur）、目标结点的前驱结点（pre）、目标结点的后继结点（next）。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> reverseList <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 初始化前驱结点为 null</span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化目标结点为头结点</span>
    <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 只要目标结点不为 null，遍历就得继续</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 记录一下 next 结点</span>
        <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 反转指针</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// pre 往前走一步</span>
        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// cur往前走一步</span>
        cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 反转结束后，pre 就会变成新链表的头结点</span>
    <span class="token keyword">return</span> pre
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/" target="_blank" rel="noopener"><strong>3、反转链表 II</strong></a></p>
<p>局部反转链表需要考虑的是局部反转链表的前驱和后继指向。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */</span>
<span class="token comment" spellcheck="true">// 入参是头结点、m、n</span>
<span class="token keyword">const</span> reverseBetween <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 定义pre、cur，用leftHead来承接整个区间的前驱结点</span>
    <span class="token keyword">let</span> pre<span class="token punctuation">,</span>cur<span class="token punctuation">,</span>leftHead
    <span class="token comment" spellcheck="true">// 别忘了用 dummy 嗷</span>
    <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token comment" spellcheck="true">// dummy后继结点是头结点</span>
    dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head
    <span class="token comment" spellcheck="true">// p是一个游标，用于遍历，最初指向 dummy</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> dummy  
    <span class="token comment" spellcheck="true">// p往前走 m-1 步，走到整个区间的前驱结点处</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 缓存这个前驱结点到 leftHead 里</span>
    leftHead <span class="token operator">=</span> p
    <span class="token comment" spellcheck="true">// start 是反转区间的第一个结点</span>
    <span class="token keyword">let</span> start <span class="token operator">=</span> leftHead<span class="token punctuation">.</span>next  
    <span class="token comment" spellcheck="true">// pre 指向start</span>
    pre <span class="token operator">=</span> start
    <span class="token comment" spellcheck="true">// cur 指向 start 的下一个结点</span>
    cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next
    <span class="token comment" spellcheck="true">// 开始重复反转动作</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>m<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre
        pre <span class="token operator">=</span> cur
        cur <span class="token operator">=</span> next
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//  leftHead 的后继结点此时为反转后的区间的第一个结点</span>
    leftHead<span class="token punctuation">.</span>next <span class="token operator">=</span> pre
    <span class="token comment" spellcheck="true">// 将区间内反转后的最后一个结点 next 指向 cur</span>
    start<span class="token punctuation">.</span>next<span class="token operator">=</span>cur
    <span class="token comment" spellcheck="true">// dummy.next 永远指向链表头结点</span>
    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="链表成环问题及其衍生题目"><a href="#链表成环问题及其衍生题目" class="headerlink" title="链表成环问题及其衍生题目"></a>链表成环问题及其衍生题目</h3><p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800354676744" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
<p><a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noopener"><strong>1、环形链表</strong></a></p>
<p>遍历一个环形链表，判断是否有flag，如果有flag，则说明是环形链表，如果结点没有flag，则设立flag。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @return {boolean}
 */</span>
<span class="token comment" spellcheck="true">// 入参是头结点 </span>
<span class="token keyword">const</span> hasCycle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 只要结点存在，那么就继续遍历</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果 flag 已经立过了，那么说明环存在</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果 flag 没立过，就立一个 flag 再往</span>
            下走
            head<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener"><strong>2、环形链表 II</strong></a></p>
<p>我们从头开始遍历一个链表，假如途中进入了一个环，那么首先被打上 flag 标签的其实就是环的起点。待我们遍历完这个环时，即便环上所有的结点都已经被立了 flag，但起点处的 flag 一定最先被我们定位到。因此，我们只需要在第一次发现 flag 已存在时，将对应的结点返回即可。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> detectCycle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            head<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>快慢指针实现。我们使用两个指针，fast与 slow。它们起始都位于链表的头部。整个链表的长度为s，随后，slow 指针每次向后移动一个位置，移动到链表尾部需要t次，而 fast 指针向后移动两个位置，移动到链表尾部需要2t次。如果链表中存在环，则 2t - t = s 即 t = s 的时候，fast 指针最终将再次与 slow 指针在环中相遇。</p>
<p>当发现 slow与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */</span>

<span class="token comment" spellcheck="true">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">var</span> detectCycle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">===</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> ptr <span class="token operator">=</span> head<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>ptr <span class="token operator">!==</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote>
<p>详情可参考：<a href="https://juejin.cn/book/6844733800300150797/section/6844733800346288141" target="_blank" rel="noopener">前端算法与数据结构面试 - 修言小册</a></p>
</blockquote>
<h3 id="基础知识-4"><a href="#基础知识-4" class="headerlink" title="基础知识"></a>基础知识</h3><p>计算机世界的树结构是对现实世界中树的一层简化：把树根抽象为“根结点”，树枝抽象为“边”，树枝的两个端点抽象为“结点”，树叶抽象为“叶子结点”。</p>
<p><img src="https://secure2.wostatic.cn/static/qMsU4sXe4nxvMWgqZ3MAHU/image.png?auth_key=1678593221-tfgLbUCewkWyqrfomWNyES-0-f30bfb03c49a984f15b0a61b0aa8b777" alt="img"></p>
<p>树的关键特性有以下几点：</p>
<ul>
<li>树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。</li>
<li>结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度，即叶子结点和根节点的层数。树中结点的最大高度，称为“树的高度”。</li>
<li>“度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。</li>
<li>“叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。</li>
</ul>
<h3 id="二叉树创建"><a href="#二叉树创建" class="headerlink" title="二叉树创建"></a>二叉树创建</h3><p>二叉树是指满足以下要求的树：</p>
<ul>
<li>它可以没有根结点，作为一棵空树存在</li>
<li>如果它不是空树，那么<strong>必须由根结点、左子树和右子树组成，且左右子树都是二叉树</strong>。</li>
</ul>
<p><img src="https://secure2.wostatic.cn/static/4GdirQWdUzj7vDrqFgYCSE/image.png?auth_key=1678593221-2jDzyY6eoFYZzKkxiFwjk7-0-6b6dc081b8533e85074487ba3fed8cb9" alt="img"></p>
<p>注意，<strong>二叉树不能被简单定义为每个结点的度都是2的树</strong>。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。</p>
<h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><p>在 JS 中，二叉树使用对象来定义。它的结构分为三块：</p>
<ul>
<li>数据域</li>
<li>左侧子结点（左子树根结点）的引用</li>
<li>右侧子结点（右子树根结点）的引用</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 二叉树结点的构造函数</span>
<span class="token keyword">function</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> node  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<p>一棵二叉树的实际形态如下：</p>
<p><img src="https://secure2.wostatic.cn/static/x3R2TGxntb1PSE4dRLSYGv/image.png?auth_key=1678593221-oo1hEA9s5tqCcn1VG1ok4A-0-83726d356e05b9853a809a5c942706f2" alt="img"></p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：</p>
<ul>
<li>先序遍历：根结点 -&gt; 左子树 -&gt; 右子树</li>
<li>中序遍历：左子树 -&gt; 根结点 -&gt; 右子树</li>
<li>后序遍历：左子树 -&gt; 右子树 -&gt; 根结点</li>
<li>层次遍历</li>
</ul>
<p>按照实现方式的不同，遍历方式又可以分为以下两种：</p>
<ul>
<li>递归遍历（先、中、后序遍历）</li>
<li>迭代遍历（层次遍历）</li>
</ul>
<p><img src="https://secure2.wostatic.cn/static/6iRF1uerGGPiRGBw7RqEi7/image.png?auth_key=1678593221-9mxDUEuT5rRfX3K5rDbcx4-0-983d0ee24d93597c5e86ba97221b1fb1" alt="img"></p>
<p>上面图例展示的二叉树结构，编码实现是下面的结构：</p>
<pre class=" language-json"><code class="language-json">const root = <span class="token punctuation">{</span>
  val<span class="token operator">:</span> <span class="token string">"A"</span><span class="token punctuation">,</span>
  left<span class="token operator">:</span> <span class="token punctuation">{</span>
    val<span class="token operator">:</span> <span class="token string">"B"</span><span class="token punctuation">,</span>
    left<span class="token operator">:</span> <span class="token punctuation">{</span>
      val<span class="token operator">:</span> <span class="token string">"D"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    right<span class="token operator">:</span> <span class="token punctuation">{</span>
      val<span class="token operator">:</span> <span class="token string">"E"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  right<span class="token operator">:</span> <span class="token punctuation">{</span>
    val<span class="token operator">:</span> <span class="token string">"C"</span><span class="token punctuation">,</span>
    right<span class="token operator">:</span> <span class="token punctuation">{</span>
      val<span class="token operator">:</span> <span class="token string">"F"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>递归法：先序遍历编写递归函数编码实现，递归函数主要包括：递归式（每一次重复的内容是什么，在这里表示 根结点 -&gt; 左子树 -&gt; 右子树）和递归边界（指的是<strong>什么时候停下来</strong>）。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 先序遍历核心伪代码</span>
<span class="token keyword">function</span> <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 递归边界，root 为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 输出当前遍历的结点值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'当前遍历的结点值是：'</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
    <span class="token comment" spellcheck="true">// 递归遍历左子树 </span>
    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  
    <span class="token comment" spellcheck="true">// 递归遍历右子树  </span>
    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> preorderTraversal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> preOrder <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>迭代法：递归和栈有着脱不开的干系。本题的思路就是通过<strong>合理地安排入栈和出栈的时机、使栈的出栈序列符合二叉树的前序遍历规则</strong>。</p>
<p>先序遍历规则 根→ 左 → 右 即为出栈序列，那么入栈序列就应该为 右→左→根，因此最终的出入栈顺序应该是这样的：</p>
<ol>
<li>将根结点入栈</li>
<li>取出栈顶结点，将结点值 <code>push</code> 进结果数组</li>
<li>若栈顶结点有右孩子，则将右孩子入栈</li>
<li>若栈顶结点有左孩子，则将左孩子入栈</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">const</span> preorderTraversal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 定义结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
  <span class="token comment" spellcheck="true">// 处理边界条件</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 初始化栈结构</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 
  <span class="token comment" spellcheck="true">// 首先将根结点入栈</span>
  stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>  
  <span class="token comment" spellcheck="true">// 若栈不为空，则重复出栈、入栈操作</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 将栈顶结点记为当前结点</span>
      <span class="token keyword">const</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
      <span class="token comment" spellcheck="true">// 当前结点就是当前子树的根结点，把这个结点放在结果数组的尾部</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true">// 若当前子树根结点有右孩子，则将右孩子入栈</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">// 若当前子树根结点有左孩子，则将左孩子入栈</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span></code></pre>
<p>先序遍历结果：ABDECF</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>递归法：递归式为左子树 -&gt; 根结点 -&gt; 右子树，递归边界照旧，编码实现如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 所有遍历函数的入参都是树的根结点对象</span>
<span class="token keyword">function</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 递归边界，root 为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 递归遍历左子树 </span>
    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  
    <span class="token comment" spellcheck="true">// 输出当前遍历的结点值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'当前遍历的结点值是：'</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
    <span class="token comment" spellcheck="true">// 递归遍历右子树  </span>
    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>迭代法：中序遍历的序列规则是 <code>左 -&gt; 中 -&gt; 右</code> ，这意味着我们必须首先定位到最左的叶子结点。在这个定位的过程中，必然会途径目标结点的父结点、爷爷结点和各种辈分的祖宗结点。 途径过的每一个结点，我们都要及时地把它入栈。这样当最左的叶子结点出栈时，第一个回溯到的就是它的父结点。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">const</span> inorderTraversal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 定义结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
  <span class="token comment" spellcheck="true">// 初始化栈结构</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   
  <span class="token comment" spellcheck="true">// 用一个 cur 结点充当游标</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> root  
  <span class="token comment" spellcheck="true">// 当 cur 不为空、或者 stack 不为空时，重复以下逻辑</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">||</span> stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 这个 while 的作用是把寻找最左叶子结点的过程中，途径的所有结点都记录下来 </span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 将途径的结点入栈</span>
          stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>  
          <span class="token comment" spellcheck="true">// 继续搜索当前结点的左孩子</span>
          cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left  
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">// 取出栈顶元素</span>
      cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
      <span class="token comment" spellcheck="true">// 将栈顶元素入栈</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
      <span class="token comment" spellcheck="true">// 尝试读取 cur 结点的右孩子</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 返回结果数组</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>中序遍历结果：DBEACF</p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>递归法：递归式为左子树 -&gt; 右子树 -&gt; 根结点 ，递归边界照旧，编码实现如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 递归边界，root 为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 递归遍历左子树 </span>
    <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  
    <span class="token comment" spellcheck="true">// 递归遍历右子树  </span>
    <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 输出当前遍历的结点值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'当前遍历的结点值是：'</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
<span class="token punctuation">}</span></code></pre>
<p>迭代法：同先序遍历实现方式，后序遍历是 左→右→根，我们可以直接把 <code>pop</code> 出来的当前结点 <code>unshift</code> 进 <code>res</code> 的头部，然后左右结点的入栈顺序。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">const</span> postorderTraversal <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 定义结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
  <span class="token comment" spellcheck="true">// 处理边界条件</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 初始化栈结构</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 
  <span class="token comment" spellcheck="true">// 首先将根结点入栈</span>
  stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>  
  <span class="token comment" spellcheck="true">// 若栈不为空，则重复出栈、入栈操作</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 将栈顶结点记为当前结点</span>
      <span class="token keyword">const</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
      <span class="token comment" spellcheck="true">// 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部</span>
      res<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true">// 若当前子树根结点有左孩子，则将左孩子入栈</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>  
      <span class="token comment" spellcheck="true">// 若当前子树根结点有右孩子，则将右孩子入栈</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 返回结果数组</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>后序遍历结果：DEBFCA</p>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>按照层次的顺序，从上到下，从左到右地遍历一个二叉树，使用队列存储，编码实现如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment" spellcheck="true">/**
 * @param {TreeNode} root
 * @return {number[][]}
 */</span>
<span class="token keyword">var</span> levelOrder <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> results<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//定义队列</span>
    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果root不为null，往队列添加root</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//记录当前层中节点的个数</span>
        <span class="token keyword">let</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//从队列中弹出当前层中的元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//将弹出节点的左右孩子添加到队列中</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//每弹出该层一个元素，size需要更新</span>
            size<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//将每层元素的结果放入results数组</span>
        results<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> results<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>后序遍历结果：ABCDEF</p>
<h2 id="DFS和BFS"><a href="#DFS和BFS" class="headerlink" title="DFS和BFS"></a>DFS和BFS</h2><p>练习题目没太看明白，需要多刷几遍</p>
<h3 id="DFS：深度优先遍历"><a href="#DFS：深度优先遍历" class="headerlink" title="DFS：深度优先遍历"></a>DFS：深度优先遍历</h3><p><img src="https://secure2.wostatic.cn/static/9zAmJ3JP5oitRx9evTaUPj/image.png?auth_key=1678593241-gQuE2r2AvewTSu8REwomyd-0-86958f3f426f5756c29bfc07a559b69c" alt="img"></p>
<p>深度优先搜索的过程可以转化为一系列的入栈、出栈操作。DFS 中，我们往往使用<strong>递归</strong>来模拟入栈、出栈的逻辑。深度优先搜索过程就类似于树的先序遍历、是树的先序遍历的推广。</p>
<h3 id="BFS：广度优先遍历"><a href="#BFS：广度优先遍历" class="headerlink" title="BFS：广度优先遍历"></a>BFS：广度优先遍历</h3><p><img src="https://secure2.wostatic.cn/static/wyY1KjR8VUPjqYvz7rgwyM/image.png?auth_key=1678593241-uZmyRv6NsBrkf5DmwF3FF9-0-78d016cee25161fd1b27b832eed7f781" alt="img"></p>
<p>广度优先搜索每次<strong>以“广度”为第一要务、雨露均沾，一层一层地扫描</strong>。</p>
<p>在分层遍历的过程中，会发现两个规律：</p>
<ol>
<li>每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。</li>
<li>站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。</li>
</ol>
<p>丢弃已访问的坐标、记录新观察到的坐标，这个顺序毫无疑问符合了“先进先出”的原则，因此整个 BFS 算法的实现过程，<strong>和队列有着密不可分的关系</strong>。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">BFS</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 初始化队列queue</span>
    <span class="token comment" spellcheck="true">// 根结点首先入队</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 队列不为空，说明没有遍历完全</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> top <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 取出队头元素  </span>
        <span class="token comment" spellcheck="true">// 访问 top</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// 如果左子树存在，左子树入队</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果右子树存在，右子树入队</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 访问完毕，队头元素出队</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                                    <span class="chip bg-color">前端算法与数据结构</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '69981b3a8d9bb8970c58',
        clientSecret: '2dced5add1e38f1190f6537ae3fc262808dbb905',
        repo: 'gitalk',
        owner: 'cyh756085049',
        admin: "cyh756085049",
        id: '2023-03-12T13-11-46',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'dkHeciAxwC6Al978y1RSxiqq-gzGzoHsz',
        appKey: 'W1ENUD4DHJ1IfDpTEQ8JeBFW',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2023/03/12/qian-duan-suan-fa-yu-shu-ju-jie-gou/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="前端算法与数据结构">
                        
                        <span class="card-title">前端算法与数据结构</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            前端基本算法与数据结构知识
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-category">
                                    数据结构与算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                        <span class="chip bg-color">前端算法与数据结构</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/01/10/cona-an-zhuang/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="cona安装">
                        
                        <span class="card-title">cona安装</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            conda安装
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-01-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B7%A5%E5%85%B7/" class="post-category">
                                    工具
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Anaconda/">
                        <span class="chip bg-color">Anaconda</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://cyh756085049.github.io" target="_blank">cyh</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank"> hexo-theme-matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">187k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/cyh756085049" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:756085049@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=756085049" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 756085049" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "看不见我🙈~看不见我🙈~", clearTimeout(st)) : (document.title = "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) }) </script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/ppfzpxwqiaxotmryofkmshcnaz4vmxsv.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
